<!DOCTYPE html> 
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <script src="../build/three.js" type="text/javascript" ></script>
        <script src="../examples/js/Detector.js" type="text/javascript" ></script>
        <script src="../examples/js/loaders/OBJLoader.js" type="text/javascript" ></script>
        <script src="../examples/js/controls/OrbitControls.js" type="text/javascript"  ></script>
        <style type="text/css">
        body{
            margin:0;
            height:100%;   
        }
            #canvas3d{

                margin:0;
                border:1px solid red;
                min-height: 300px;
                /*height:100%;   */
                box-sizing: content-box;   
                position: relative;           
            }          
        </style>
        <style type="text/css">
              #progress{
                margin:0; 
                border:1px solid red;
                line-height:40px; 
                font-weight:bold; 
                text-align:center;
                background-color:#ff0000; 
            }
        </style>
        <style type="text/css" >
            #c{
                position: absolute;
                top: 50%;
                width:100%;
                text-align: center;
            }
        </style>
    </head>
    <body >
    <div id = "progress">
        <p>测试</p>
    </div>

    <div id = "canvas3d">  
        <div id="c">
        <p>开始加载</p>
        </div>
    </div>

    <script type="text/javascript">

   
    if(Detector.webgl){
        init();
        animate();
    }else{
        alert('浏览器不支持');
    }
  
    var camera, scene,renderer,controls;

    //这里，需要声明全局的几个对象，光标坐标（屏幕坐标），射线 ，探测到的物体集合
    var mouse, raycaster, INTERSECTED;
    var w ,h;
    //初始化
    function init(){
        w = document.getElementById("canvas3d").clientWidth;
        h = document.getElementById("canvas3d").clientHeight;

//初始化
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2(),



        scene = new THREE.Scene();
       
        var b = new THREE.BoxGeometry(3,3,3);

        // for(var i=0;i<500;i++){
        //     var v = new THREE.Mesh( b, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
        //     v.position.x=Math.random()* 100-50;
        //     v.position.y =Math.random()*80-40;
        //     v.position.z=Math.random()*60-30;
        //     v.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI)
        //     v.scale.x=Math.random()*2;
        //     v.scale.y=Math.random()*2;
        //     v.scale.z=Math.random()*2;
        //     scene.add(v);
        // }


        camera = new THREE.PerspectiveCamera(45,w/h,0.1,1000);
        camera.position.z= 250;
        var directionalLight = new THREE.SpotLight( 0xffeedd );
        directionalLight.position.set( 22, 55, 44 );
        directionalLight.castShadow = true;
       directionalLight.shadow = new THREE.LightShadow( camera );
                directionalLight.shadow.bias = - 0.00022;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
        scene.add( directionalLight );
        
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(w,h);
        renderer.setClearColor(0xf0f0f0); 
 
        document.getElementById('canvas3d').appendChild(renderer.domElement);
//下面是加载纹理及模型，和之前做法一样，我这里注释去掉。以免代码太长。
//
        var manager = new THREE.LoadingManager();     
        
        //模型需要纹理Texture
        var texture = new THREE.Texture();
        var loader = new THREE.ImageLoader( manager );
        loader.load( 'knotTex.png', function ( image ) {
            texture.image = image;
            texture.needsUpdate = true;
        } );
        var loader = new THREE.OBJLoader(manager);
        var onLoad = function(object){            
            object.traverse( function ( child ) {
                if ( child instanceof THREE.Mesh ) {
                    //child.material.map = texture;
                     child.castShadow = true;
                     child.receiveShadow = true;
                   
                     scene.add( child);    
                }
            } );
            document.getElementById('c').innerText= '' ;           
        }
        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
                document.getElementById('c').innerText= Math.round(percentComplete, 2) + '%下载' ;
            }
        };
        var onError = function ( xhr ) {

        };
        loader.load('vvps.obj',onLoad,onProgress,onError);     


        controls=new THREE.OrbitControls(camera);


    //这里记得要添加鼠标移动事件
        //document.addEventListener('mousemove',onDocumentMouseMove,false); 
    } 
  //   function onDocumentMouseMove( event ) {
        
  //       event.preventDefault();
  //       //mouse的值范围在 -1---1之间。我们做个转换
  //       mouse.x = ( event.clientX / w ) * 2 - 1;
  //       mouse.y = - ( (event.clientY - 74) /h) * 2 + 1;
     
  // }
  //   //窗口变化时，3D窗口也会动态适配
  //   window.onresize = function(){ 
  //       w = document.getElementById("canvas3d").clientWidth;
  //       h = document.getElementById("canvas3d").clientHeight;
  //       camera.aspect = w/h;
  //       camera.updateProjectionMatrix();
  //       renderer.setSize(w,h); 
  //   }

    // 渲染
    function render(){
        //这里是更新射线的起点和方向    
        raycaster.setFromCamera( mouse, camera );

        // //他有2个参数，第一个是射线检探测的物体集，第二个是是否开启物体子物体检测,默认不开启(false)
        // var intersects = raycaster.intersectObjects( scene.children );              
     
        // if ( intersects.length > 0 ) {
        //     if ( INTERSECTED != intersects[0].object ) {

        //          if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
        //          INTERSECTED = intersects[ 0 ].object;
        //          INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
        //          INTERSECTED.material.emissive.setHex( 0xff0000 );

        //      }
        // } else {
        //     if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
        //     INTERSECTED = null;
        // }

             
        renderer.render(scene,camera);
    }
    //循环渲染
    function animate() {
        requestAnimationFrame( animate );
        render();
    } 

    </script>
    </body>
</html>